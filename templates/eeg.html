<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EEG Real-Time Viewer</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        // Configure Tailwind
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'primary-bg': '#0a0a0a',
                        'secondary-bg': '#1f2937',
                        'accent': '#00eaff',
                        'accent-hover': '#00bcd4',
                        'text-light': '#e5e7eb',
                        'text-dark': '#030712',
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    }
                }
            }
        }
    </script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        .plot-container { min-height: 600px; }
        .channel-list::-webkit-scrollbar { width: 8px; }
        .channel-list::-webkit-scrollbar-track { background: #1f2937; }
        .channel-list::-webkit-scrollbar-thumb { background-color: #374151; border-radius: 4px; }
        .channel-list::-webkit-scrollbar-thumb:hover { background-color: #4b5563; }
        .hidden { display: none; } 
        /* NEW: Class for disabled channel selection area */
        .disabled-input { opacity: 0.6; pointer-events: none; }
        /* Added button styles */
        .btn-secondary {
            background-color: #374151; /* Gray-700 equivalent */
            color: #e5e7eb; /* text-light */
            transition: background-color 0.2s;
        }
        .btn-secondary:hover:enabled {
            background-color: #4b5563; /* Gray-600 equivalent */
        }
    </style>
</head>
<body class="min-h-screen bg-primary-bg text-text-light p-4">

    <div class="container mx-auto">
        <h1 class="text-3xl font-extrabold text-accent mb-6 text-center">Real-Time EEG Signal Analyzer</h1>

        <div class="flex flex-col md:flex-row gap-6">
            
            <div class="md:w-1/4 bg-secondary-bg p-6 rounded-xl shadow-2xl sidebar">
                <h4 class="text-xl font-semibold text-accent mb-4">EEG Controls</h4>
                
                <div class="mb-6 border-2 border-dashed border-gray-600 rounded-lg p-4 text-center hover:border-accent transition duration-300" 
                    id="dropZone">
                    <input type="file" id="edfFile" accept=".edf" class="hidden">
                    <label for="edfFile" class="cursor-pointer">
                        <svg class="mx-auto h-8 w-8 text-accent mb-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 014 4.903V18a2 2 0 01-2 2H5a2 2 0 01-2-2z" />
                        </svg>
                        <p class="text-sm font-medium">Drag & drop or <span class="text-accent font-bold">click to upload</span> an **EDF** file</p>
                    </label>
                    <p id="fileNameDisplay" class="text-xs text-gray-400 mt-2">No file loaded.</p>
                </div>

                <form id="channelForm" class="hidden">
                    <div class="mb-4">
                        <label for="width" class="block text-sm font-medium mb-1">Window width (seconds)</label>
                        <input type="number" id="width" name="width" 
                                class="w-full p-2 bg-gray-700 text-text-light border border-gray-600 rounded-lg focus:ring-accent focus:border-accent" 
                                value="5" min="1" step="1">
                    </div>

                    <div class="mb-4">
                        <label for="graphMode" class="block text-sm font-medium mb-1">Graph Mode</label>
                        <select id="graphMode" 
                                class="w-full p-2 bg-gray-700 text-text-light border border-gray-600 rounded-lg focus:ring-accent focus:border-accent">
                            <option value="time">Time Graph (Multi-Channel)</option>
                            <option value="polar">Polar Graph (Multi-Channel)</option>
                            <option value="recurrence">Recurrence Graph (Single Channel)</option>
                            <option value="cycle">Cycle Based Analysis (Single/Averaged)</option>
                        </select>
                    </div>

                    <div class="mb-4" id="montageSelectorContainer">
                        <label for="montageSelector" class="block text-sm font-medium mb-1">Quick Channel Set (Montage)</label>
                        <select id="montageSelector"
                                class="w-full p-2 bg-gray-700 text-text-light border border-gray-600 rounded-lg focus:ring-accent focus:border-accent">
                            <option value="none">Custom Selection (Show All Channels)</option>
                            <option value="standard">Standard 10-20 Subset</option>
                            <option value="frontal">Frontal Lobe Only</option>
                            <option value="occipital">Occipital Lobe Only</option>
                            <option value="all">Select All Channels (May be slow/cluttered)</option>
                        </select>
                    </div>

                    <div id="channelSelectionContainer" class="mb-6">
                        <label class="block text-sm font-medium mb-2">Select Channels</label>
                        
                        <div id="channelInstructions" class="text-xs text-yellow-400 mb-2 p-2 bg-yellow-900/20 rounded hidden">
                            Hint: For this mode, selecting one channel is highly recommended.
                        </div>

                        <div id="channelList" class="channel-list p-3 rounded-lg border border-gray-700 bg-gray-800 max-h-40 overflow-y-auto">
                            <p class="text-center text-gray-500">Channels load after file upload.</p>
                        </div>
                    </div>

                    <div class="flex gap-2 mb-2">
                        <button type="submit" id="startContinueButton" class="w-1/2 bg-accent hover:bg-accent-hover text-text-dark font-extrabold py-2 rounded-lg transition duration-200 shadow-lg" >
                            Start Streaming
                        </button>
                        <button type="button" id="pauseButton" onclick="pauseStreaming()" class="w-1/2 btn-secondary font-extrabold py-2 rounded-lg transition duration-200 shadow-lg opacity-50 cursor-not-allowed" disabled>
                            Pause
                        </button>
                    </div>

                    <button type="button" id="stopButton" class="w-full bg-red-700 hover:bg-red-600 text-text-light font-extrabold py-2 rounded-lg transition duration-200 shadow-lg opacity-50 cursor-not-allowed" disabled onclick="stopStreaming()">
                            Stop Streaming (Reset)
                    </button>
                </form>
            </div>

            <div class="md:w-3/4 bg-secondary-bg p-4 rounded-xl shadow-2xl plot-container">
                <h4 class="text-xl font-semibold text-accent mb-4">EEG Signal Viewer</h4>
                <div id="plot" style="width:100%;height:600px;">
                    <div class="text-center p-10 text-xl text-gray-500">
                        Please upload an EDF file to begin analysis.
                    </div>
                </div>
            </div>
        </div>
    </div>
    
<script>
    // --- GLOBAL VARIABLES ---
    let isStreaming = false; // Indicates if the app is in an active streaming session (started)
    let isPaused = false; // Indicates if streaming is paused (interval is cleared, but buffers/graph exist)
    let intervalId;
    let selected = [];
    let width = 5;
    let fs = 160; 
    let channelDataBuffers = {};
    let globalTime = 0; 
    let bandPowerBuffer = {};
    let currentYRange = 500000; 
    const colors = ["#FF5733","#33FF57","#3357FF","#F3FF33","#FF33EC","#33FFF6","#FF8F33","#8F33FF","#33FF99","#FF3333"];
    
    const startContinueButton = document.getElementById('startContinueButton');
    const pauseButton = document.getElementById('pauseButton'); // NEW
    const stopButton = document.getElementById('stopButton');
    const channelListDiv = document.getElementById('channelList');
    const channelForm = document.getElementById('channelForm');
    const plotContainerDiv = document.getElementById('plot'); 
    const graphModeSelector = document.getElementById('graphMode');
    const montageSelector = document.getElementById('montageSelector');
    const montageSelectorContainer = document.getElementById('montageSelectorContainer');
    const channelInstructions = document.getElementById('channelInstructions');
    const channelSelectionContainer = document.getElementById('channelSelectionContainer'); 
    
    let channelNameMap = {}; 
    let channelIndexToOriginalName = {}; 
    let allAvailableChannels = {}; 

    
    // Define standard 10-20 channel names (cleaned/uppercase)
    const montages = {
        'standard': ['FP1', 'FP2', 'F3', 'F4', 'C3', 'C4', 'P3', 'P4', 'O1', 'O2', 'FZ', 'CZ', 'PZ'], 
        'frontal': ['FP1', 'FP2', 'F3', 'F4', 'F7', 'F8', 'FZ'],
        'occipital': ['P3', 'P4', 'O1', 'O2', 'OZ'],
        'all': [] 
    };

    // --- NEW: Button State Management ---
    function updateButtonStates() {
        // Start/Continue Button
        startContinueButton.disabled = isStreaming && !isPaused;
        startContinueButton.classList.toggle('opacity-50', isStreaming && !isPaused);
        startContinueButton.classList.toggle('cursor-not-allowed', isStreaming && !isPaused);
        startContinueButton.textContent = isStreaming ? (isPaused ? 'Continue Streaming' : 'Running...') : 'Start Streaming';
        
        // Pause Button
        pauseButton.disabled = !isStreaming || isPaused;
        pauseButton.classList.toggle('opacity-50', !isStreaming || isPaused);
        pauseButton.classList.toggle('cursor-not-allowed', !isStreaming || isPaused);

        // Stop Button
        stopButton.disabled = !isStreaming;
        stopButton.classList.toggle('opacity-50', !isStreaming);
        stopButton.classList.toggle('cursor-not-allowed', !isStreaming);
    }

    // --- CORE LOGIC FOR DYNAMIC CHANNEL LIST RENDERING (Unchanged) ---

    function cleanChannelName(name) {
        return name.trim().toUpperCase().split(/[-_/\s().]/)[0].replace(/[^A-Z0-9]/g, '');
    }

    function renderChannelCheckboxes(channelsToShow) {
        channelListDiv.innerHTML = ''; 
        
        const sortedIndices = Object.keys(channelsToShow).sort((a, b) => parseInt(a) - parseInt(b));

        if (sortedIndices.length === 0 && Object.keys(allAvailableChannels).length > 0) {
             channelListDiv.innerHTML = '<p class="text-center text-red-400">No channels found for this montage!</p>';
             return;
        }

        if (sortedIndices.length === 0) {
            channelListDiv.innerHTML = '<p class="text-center text-gray-500">Channels load after file upload.</p>';
            return;
        }

        sortedIndices.forEach(index => {
            const name = channelsToShow[index];
            const div = document.createElement('div');
            div.className = 'flex items-center mb-1';
            div.innerHTML = `<input class="form-check-input h-4 w-4 text-accent bg-gray-700 border-gray-600 rounded focus:ring-accent" 
                                 type="checkbox" name="channels" value="${index}" id="ch${index}">
                                 <label class="ml-2 text-sm" for="ch${index}">${name} (${parseInt(index) + 1})</label>`;
            channelListDiv.appendChild(div);
        });
    }
    
    function applyMontage(montageKey) {
        const channelsToShow = {};
        let selectedMontageNames = [];

        if (montageKey === 'none' || montageKey === 'all') {
            Object.assign(channelsToShow, allAvailableChannels);
        } else {
            selectedMontageNames = montages[montageKey] || [];
        }
        
        if (selectedMontageNames.length > 0) {
            selectedMontageNames.forEach(standardName => {
                const cleanedName = cleanChannelName(standardName);
                const index = channelNameMap[cleanedName];
                if (index !== undefined) {
                    channelsToShow[index] = channelIndexToOriginalName[index];
                }
            });
        }

        renderChannelCheckboxes(channelsToShow);
        
        document.querySelectorAll("input[name=channels]").forEach(cb => {
            cb.disabled = false;
            if (montageKey === 'all') {
                cb.checked = true;
            } else {
                cb.checked = false;
            }
        });
    }
    
    function toggleChannelListDisplay() {
        const currentMode = graphModeSelector.value;
        
        if (currentMode !== 'time') {
            montageSelectorContainer.classList.remove('hidden');
            channelSelectionContainer.classList.remove('disabled-input');
        } else {
            montageSelectorContainer.classList.remove('hidden');
            channelInstructions.classList.add('hidden');
            channelSelectionContainer.classList.remove('disabled-input');
        }
        
        if (currentMode === 'recurrence' || currentMode === 'cycle') {
            channelInstructions.classList.remove('hidden');
            channelInstructions.innerHTML = '⚠️ **SINGLE CHANNEL MODE:** Please select only **one** channel for this graph type.';
        } else {
             channelInstructions.classList.add('hidden');
        }
        
        montageSelector.value = 'none';
        applyMontage('none'); 
    }

    // Event Listeners
    montageSelector.addEventListener('change', (e) => {
        applyMontage(e.target.value);
    });
    
    graphModeSelector.addEventListener('change', () => {
        toggleChannelListDisplay(); 
    });

    // --- FILE UPLOAD HANDLERS (Unchanged) ---
    function handleFileUpload(file) {
        if (!file || file.name.split('.').pop().toLowerCase() !== 'edf') {
            alert("Please select a valid EDF file.");
            return;
        }
        
        document.getElementById('fileNameDisplay').textContent = `Uploading: ${file.name}...`;
        stopStreaming(); 
        channelForm.classList.add('hidden'); 
        updateButtonStates(); // Reset buttons

        const formData = new FormData();
        formData.append('file', file);

        fetch("/eeg/upload", {
            method: "POST",
            body: formData
        })
        .then(response => {
            if (!response.ok) {
                throw new Error(`Server returned status: ${response.status}`);
            }
            return response.json();
        })
        .then(result => {
            if (result.success) {
                fs = result.fs;
                
                channelNameMap = {};
                channelIndexToOriginalName = {};
                allAvailableChannels = {};
                
                Object.entries(result.channels).forEach(([index, name]) => {
                    const cleanedName = cleanChannelName(name); 
                    channelNameMap[cleanedName] = index; 
                    channelIndexToOriginalName[index] = name; 
                    allAvailableChannels[index] = name; 
                });
                
                document.getElementById('fileNameDisplay').textContent = `File Loaded: ${file.name} (FS: ${fs} Hz, ${Object.keys(result.channels).length} Ch)`;
                channelForm.classList.remove('hidden');
                
                graphModeSelector.value = 'time'; 
                montageSelector.value = 'none';
                toggleChannelListDisplay(); 
                
                // Clear the main container and show instructions
                Plotly.purge('plot'); // Clear any existing plots
                plotContainerDiv.innerHTML = '<div id="plot"><div class="text-center p-10 text-xl text-gray-500">Select channels and click \'Start Streaming\'.</div></div>';
                updateButtonStates(); // Set initial button states

            } else {
                document.getElementById('fileNameDisplay').textContent = `Error: ${result.message}`;
                alert(`File upload failed: ${result.message}`);
            }
        })
        .catch(error => {
            console.error("Upload error:", error);
            document.getElementById('fileNameDisplay').textContent = `Upload failed: Network or Server Error.`;
        });
    }
    
    // --- Drag and Drop Listeners (Unchanged) ---
    const dropZone = document.getElementById('dropZone');
    const edfFileInput = document.getElementById('edfFile');

    edfFileInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) handleFileUpload(file);
    });
    
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        dropZone.addEventListener(eventName, preventDefaults, false);
        document.body.addEventListener(eventName, preventDefaults, false);
    });

    function preventDefaults (e) {
        e.preventDefault();
        e.stopPropagation();
    }

    ['dragenter', 'dragover'].forEach(eventName => {
        dropZone.addEventListener(eventName, () => dropZone.classList.add('border-accent'), false);
    });

    ['dragleave', 'drop'].forEach(eventName => {
        dropZone.addEventListener(eventName, () => dropZone.classList.remove('border-accent'), false);
    });

    dropZone.addEventListener('drop', (e) => {
        const dt = e.dataTransfer;
        const file = dt.files[0];
        handleFileUpload(file);
    }, false);


    // --- STREAMING CONTROLS (MODIFIED) ---
    
    /**
     * Stops the streaming interval and resets state for a full stop.
     */
    function stopStreaming() {
        if (intervalId) {
            clearInterval(intervalId);
            intervalId = null;
        }
        isStreaming = false;
        isPaused = false;
        updateButtonStates();
        console.log("Streaming stopped (and reset).");
        
        // Update all plots with a 'STOPPED' title and reset container
        updatePlotTitles(" (STOPPED)");
        
        // Final reset for the plot area
        plotContainerDiv.innerHTML = '<div id="plot"><div class="text-center p-10 text-xl text-gray-500">Select channels and click \'Start Streaming\'.</div></div>';
    }

    /**
     * Pauses the streaming by clearing the interval. Data/Graph state remains intact.
     */
    function pauseStreaming() {
        if (intervalId) {
            clearInterval(intervalId);
            intervalId = null;
        }
        isPaused = true;
        updateButtonStates();
        console.log("Streaming paused.");
        
        // Update plot titles with PAUSED
        updatePlotTitles(" (PAUSED)");
    }

    /**
     * Resumes the streaming by setting the interval.
     */
    function continueStreaming() {
        if (!isStreaming || !isPaused) return;

        isPaused = false;
        intervalId = setInterval(fetchData, 100); 
        updateButtonStates();
        console.log("Streaming continued.");
        
        // Remove PAUSED/STOPPED from plot titles
        updatePlotTitles("");
    }
    
    /**
     * Helper to update plot titles across all active plots.
     */
    function updatePlotTitles(suffix) {
        const mode = graphModeSelector.value;
        if (mode === "time") {
            selected.forEach(chIndex => {
                const plotId = `plot-ch-${chIndex}`;
                try {
                    const node = Plotly.d3.select(`#${plotId}`).node();
                    if (node && node.layout) {
                        let currentTitle = node.layout.title.text.replace(/ \(PAUSED\)/g, '').replace(/ \(STOPPED\)/g, '').replace(/ \(Time: [\d\.]+s\)/, '');
                        Plotly.relayout(plotId, { title: currentTitle + suffix });
                    }
                } catch (e) { /* Ignore error if plot isn't initialized */ }
            });
        } else {
            const plotId = 'single-plot';
            try {
                const node = Plotly.d3.select(`#${plotId}`).node();
                if (node && node.layout) {
                    let currentTitle = node.layout.title.text.replace(/ \(PAUSED\)/g, '').replace(/ \(STOPPED\)/g, '').replace(/ \(Time: [\d\.]+s\)/, '');
                    Plotly.relayout(plotId, { title: currentTitle + suffix });
                }
            } catch (e) { /* Ignore error if plot isn't initialized */ }
        }
    }


    // --- START/CONTINUE STREAMING LOGIC ---
    document.getElementById("channelForm").addEventListener("submit", (e) => {
        e.preventDefault();
        
        if (isPaused) {
            // If paused, just continue
            continueStreaming();
            return;
        }
        
        if (isStreaming) {
            // If running, do nothing on submit until it's stopped/paused
            return;
        }

        // --- INITIAL STARTUP LOGIC ---

        let rawSelected = Array.from(document.querySelectorAll("#channelList input[name=channels]:checked")).map(ch => parseInt(ch.value));
        
        width = parseFloat(document.getElementById("width").value);
        mode = graphModeSelector.value;

        // --- MODE-SPECIFIC CHANNEL ENFORCEMENT ---
        if (rawSelected.length === 0) {
            Plotly.purge('plot');
            plotContainerDiv.innerHTML = '<div id="plot"><div class="text-center p-10 text-xl text-red-400">Please select at least one channel to start streaming.</div></div>';
            updateButtonStates(); 
            return;
        }

        if (mode === "recurrence" || mode === "cycle") {
            selected = [rawSelected[0]]; // Use only the first channel
        } else {
            selected = rawSelected;
        }
        // --- END MODE-SPECIFIC CHANNEL ENFORCEMENT ---

        // Reset buffers and state for the new stream
        channelDataBuffers = {};
        selected.forEach(chIndex => channelDataBuffers[chIndex] = { data: [], time: [] }); 
        globalTime = 0;
        bandPowerBuffer = {}; 
        currentYRange = 500000; 
        
        // Clear the main plot container
        Plotly.purge('plot');
        plotContainerDiv.innerHTML = '';


        // --- Plotly Configuration based on Mode (UNCHANGED) ---
        let traces, layout;
        
        if (mode === "time") {
            selected.forEach((chIndex, i) => {
                const chName = channelIndexToOriginalName[chIndex.toString()];
                const plotId = `plot-ch-${chIndex}`;
                const color = colors[i % colors.length];

                const plotDiv = document.createElement('div');
                plotDiv.id = plotId;
                plotDiv.className = 'w-full mb-4 border border-gray-700 rounded-lg p-2 bg-gray-800'; 
                plotDiv.style.height = `${Math.floor(600 / selected.length) - 10}px`; 
                plotContainerDiv.appendChild(plotDiv);

                const individualTrace = [{ 
                    x: [], y: [], mode: "lines", line: { color: color }, name: chName 
                }];
                
                const individualLayout = {
                    title: `Channel ${chName} - Time Graph - Window: ${width}s`,
                    paper_bgcolor: "#1f2937", 
                    plot_bgcolor: "#000000", 
                    font: { color: "#e5e7eb", family: "Inter" },
                    autosize: true,
                    margin: { t: 40, r: 10, b: 20, l: 30 },
                    xaxis: { title: "Time (s)", color: "#e5e7eb", gridcolor: "#374151", range: [0, width], showticklabels: true },
                    yaxis: { title: "µV", color: "#e5e7eb", gridcolor: "#374151" }
                };

                Plotly.newPlot(plotId, individualTrace, individualLayout, { responsive: true, displayModeBar: false });
            });
            
        } else if (mode === "polar" || mode === "recurrence" || mode === "cycle") {
            // Create a single container for non-time plots
            const singlePlotDiv = document.createElement('div');
            singlePlotDiv.id = 'single-plot';
            singlePlotDiv.style.width = '100%';
            singlePlotDiv.style.height = '600px';
            plotContainerDiv.appendChild(singlePlotDiv);

            const singlePlotId = 'single-plot';

            if (mode === "polar") {
                traces = selected.map((ch, i) => {
                    const name = channelIndexToOriginalName[ch.toString()];
                    return { r: [], theta: [], mode: "lines", line: { color: colors[i % colors.length] }, name, type: "scatterpolar" };
                });
                layout = {
                    title: `EEG - Polar Graph - Window: ${width}s`,
                    paper_bgcolor: "#1f2937", plot_bgcolor: "#1f2937", 
                    font: { color: "#e5e7eb", family: "Inter" },
                    polar: {
                        bgcolor: "#000000",
                        radialaxis: { title: "Amplitude (Normalized)", color: "#e5e7eb", gridcolor: "#374151" },
                        angularaxis: { direction: "clockwise", rotation: 90, color: "#e5e7eb", gridcolor: "#374151" }
                    }
                };
            } else if (mode === "recurrence") {
                traces = [{ z: [[0]], type: "heatmap", colorscale: "Viridis", showscale: true }];
                const channelName = channelIndexToOriginalName[selected[0].toString()];
                layout = {
                    title: `EEG - Recurrence Graph - ${channelName} - Window: ${width}s`,
                    paper_bgcolor: "#1f2937", plot_bgcolor: "#1f2937",
                    font: { color: "#e5e7eb", family: "Inter" },
                    xaxis: { title: "Time Index", color: "#e5e7eb", gridcolor: "#374151" },
                    yaxis: { title: "Time Index", color: "#e5e7eb", gridcolor: "#374151" }
                };
            } else if (mode === "cycle") {
                const bands = ['Delta (0.5-4Hz)', 'Theta (4-8Hz)', 'Alpha (8-13Hz)', 'Beta (13-30Hz)', 'Gamma (>30Hz)'];
                bandPowerBuffer = { bands: bands, power: Array(bands.length).fill(0) }; 
                const channelTitle = channelIndexToOriginalName[selected[0].toString()];
                traces = [{
                    x: bands, y: bandPowerBuffer.power, type: 'bar',
                    marker: { color: ['#FF5733', '#33FF57', '#3357FF', '#F3FF33', '#FF33EC'] }
                }];
                layout = {
                    title: `EEG - Scaled Band Power: ${channelTitle}`,
                    paper_bgcolor: "#1f2937", plot_bgcolor: "#1f2937",
                    font: { color: "#e5e7eb", family: "Inter" },
                    xaxis: { title: "Frequency Band", color: "#e5e7eb", gridcolor: "#374151" },
                    yaxis: { 
                        title: `Scaled Average Power (x10^10)`, color: "#e5e7eb", 
                        gridcolor: "#374151", range: [0, currentYRange] 
                    } 
                };
            }
            
            Plotly.newPlot(singlePlotId, traces, layout, { responsive: true, displayModeBar: false });
        }
        // --- End Plotly Configuration ---

        // Start the stream
        isStreaming = true;
        isPaused = false;
        intervalId = setInterval(fetchData, 100); 

        updateButtonStates();
    });

    // --- Helper functions for data buffering (Unchanged) ---
    function updateBuffer(chIndex, newSignals, newTime) {
        const buffer = channelDataBuffers[chIndex];
        const maxPoints = width * fs;
        buffer.data.push(...newSignals);
        buffer.time.push(...newTime);
        if (buffer.data.length > maxPoints) {
            const excess = buffer.data.length - maxPoints;
            buffer.data.splice(0, excess);
            buffer.time.splice(0, excess);
        }
    }

    function updateDataBuffer(chIndex, newSignals) {
        const buffer = channelDataBuffers[chIndex].data;
        const maxPoints = width * fs;
        buffer.push(...newSignals);
        if (buffer.length > maxPoints) {
            buffer.splice(0, buffer.length - maxPoints);
        }
    }

    // --- Main data fetching and plotting logic (COMPLETED) ---
    async function fetchData() {
        if (!isStreaming || isPaused) return; // Only run if streaming and not paused

        try {
            const response = await fetch("/eeg/update", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ channels: selected, width })
            });
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            const result = await response.json();

            if (result.message === "No file loaded.") {
                console.error("No file loaded, stopping stream.");
                stopStreaming();
                return;
            }

            if (!result.signals || typeof result.n_samples === 'undefined' || result.n_samples === 0) {
                return;
            }

            const N_samples = result.n_samples;
            const dt = 1 / fs; 

            // Calculate new global time
            const timeChunk = [];
            for (let i = 0; i < N_samples; i++) {
                globalTime += dt;
                timeChunk.push(globalTime);
            }

            const mode = graphModeSelector.value;
            const singlePlotId = 'single-plot';

            // Plotting logic
            if (mode === "time") {
                const xmin = globalTime - width;
                const xmax = globalTime;

                selected.forEach((chIndex) => {
                    const plotId = `plot-ch-${chIndex}`;
                    const newSignals = result.signals[chIndex.toString()]; 
                    
                    if (!newSignals || newSignals.length === 0) return;
                    
                    updateBuffer(chIndex, newSignals, timeChunk);
                    
                    const xUpdate = [channelDataBuffers[chIndex].time];
                    const yUpdate = [channelDataBuffers[chIndex].data];
                    
                    Plotly.restyle(plotId, { x: xUpdate, y: yUpdate });
                    
                    Plotly.relayout(plotId, { 
                        'xaxis.range': [xmin, xmax], 
                        'title': `Channel ${channelIndexToOriginalName[chIndex.toString()]} - Time Graph - Window: ${width}s (Time: ${globalTime.toFixed(2)}s)`
                    });
                });

            } else if (mode === "polar") {
                const rUpdate = [], thetaUpdate = [];
                selected.forEach((chIndex) => {
                    const newSignals = result.signals[chIndex.toString()];
                    if (!newSignals || newSignals.length === 0) return;
                    
                    updateDataBuffer(chIndex, newSignals);
                    const buffer = channelDataBuffers[chIndex].data;
                    const N = buffer.length;
                    const theta = buffer.map((_, idx) => (idx / (N - 1)) * 360);
                    // Use a simple normalization for polar plot radius
                    const maxAbsVal = Math.max(...buffer.map(Math.abs));
                    const r = buffer.map(v => v / maxAbsVal); 
                    
                    rUpdate.push(r); 
                    thetaUpdate.push(theta);
                });
                
                // Update Plotly for Polar Graph
                Plotly.restyle(singlePlotId, { r: rUpdate, theta: thetaUpdate });
                Plotly.relayout(singlePlotId, { 
                    'title': `EEG - Polar Graph - Window: ${width}s (Time: ${globalTime.toFixed(2)}s)` 
                });

            } else if (mode === "recurrence") {
                // Requires the backend to return the recurrence matrix (a 2D array) in result.recurrence_matrix
                if (!result.recurrence_matrix) return; 
                
                Plotly.restyle(singlePlotId, { z: [result.recurrence_matrix] });
                const channelName = channelIndexToOriginalName[selected[0].toString()];
                Plotly.relayout(singlePlotId, { 
                    'title': `EEG - Recurrence Graph - ${channelName} - Window: ${width}s (Time: ${globalTime.toFixed(2)}s)`
                });

            } else if (mode === "cycle") {
                // Requires the backend to return an array of band powers in result.band_power
                if (!result.band_power) return; 

                // Dynamically adjust the Y axis range based on current power values
                const maxPower = Math.max(...result.band_power);
                if (maxPower * 1.2 > currentYRange) {
                    currentYRange = maxPower * 1.2;
                }

                // Update Plotly for Band Power Bar Chart
                Plotly.restyle(singlePlotId, { y: [result.band_power] });
                Plotly.relayout(singlePlotId, { 
                    'yaxis.range': [0, currentYRange],
                    'title': `EEG - Scaled Band Power: ${channelIndexToOriginalName[selected[0].toString()]} (Time: ${globalTime.toFixed(2)}s)`
                });
            }

        } catch (error) {
            console.error("Data fetch or plot update error:", error);
            // Optionally alert the user or stop the stream on a critical error
            if (error.message.includes("status: 500")) {
                console.error("Server error during data update. Stopping stream.");
            }
            // If the error is network/server side, stop the loop to prevent spamming the backend
            if (!isPaused) {
                stopStreaming();
            }
        }
    }

    // Initialize button states on load
    document.addEventListener('DOMContentLoaded', () => {
        updateButtonStates();
    });

</script>
</body>
</html>