<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Real-Time ECG Viewer</title>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css"/>
<style>
  /* General body and sidebar */
  body {
    background: #000;
    color: #e0e0e0;
    font-family: Inter, sans-serif;
  }

  .sidebar {
    background: #030000;
    padding: 18px;
    border-radius: 10px;
    max-height: 95vh;
    overflow-y: auto; /* scrollable sidebar */
  }

  .plot-container {
    background: #000000;
    padding: 12px;
    border-radius: 10px;
    margin-bottom: 16px;
  }

  .prediction-box {
    background: #111;
    padding: 12px;
    border-radius: 10px;
    text-align: center;
  }

  .prediction-result {
    font-weight: 700;
    color: #00eaff;
  }

  .disease-name {
    color: #ca1414;
    font-weight: 600;
    margin-top: 6px;
  }

  /* Buttons */
  .btn-primary {
    background: #000000;
    border: 1px solid#00eaff;
    font-weight: 600;
  }
  
  .btn-primary:hover {
    background: #323739;
    border-color: #00eaff;
    color: #000;
  }
  .btn-primary {
    --bs-btn-color: #fff;
    --bs-btn-bg:#00eaff;
    --bs-btn-border-color:#00eaff;
    --bs-btn-hover-color: #fff;
    --bs-btn-hover-bg: #00e1ff;
    --bs-btn-hover-border-color: #00eaff;
    --bs-btn-focus-shadow-rgb: 49, 132, 253;
    --bs-btn-active-color: #fff;
    --bs-btn-active-bg: #303636;
    --bs-btn-active-border-color: #00eaff;
    --bs-btn-active-shadow: inset 0 3px 5px rgba(0, 0, 0, 0.125);
    --bs-btn-disabled-color: #fff;
    --bs-btn-disabled-bg: #202829;
    --bs-btn-disabled-border-color: #00e1ff;
}

  .btn-secondary {
    background: #333;
    border: 1px solid #00eaff;
    color:#e0e0e0;
  }
  .btn-secondary:hover {
    background: #444;
    border-color: #00eaff;
    color: #00fbff;
  }

  /* Drop zone */
  #dropZone {
    border: 2px dashed #00eaff;
    padding: 12px;
    border-radius: 8px;
    background: #0e0e0e;
    color: #ccc;
    text-align: center;
  }
  #pickFiles {
    color:#00eaff;
    text-decoration: underline;
    cursor: pointer;
  }
  #pickFiles:hover {
    color: #ccddd7;
  }

  /* Form inputs and selects */
  input.form-control, select.form-select {
    background: #222;
    color:#00eaff;
    border: 1px solid #00eaff;
  }

  input.form-control:focus, select.form-select:focus {
    border-color: #00eaff;
    box-shadow: 0 0 8px #00eaff;
  }

  /* Labels */
  label.form-label {
    color:#e0e0e0;
    font-weight: 500;
  }

  .form-check-label {
    color: #ccc;
  }
  

.form-check-input:checked {
    background-color: #101112;
    border-color: #e0e0e0;
}

  .form-text {
    color: #888;
  }

  /* Heading */
  h1 {
    color: #00eaff;
    text-align: center;
    font-weight: 800;
    margin-bottom: 24px;
  }

  /* frequency slider */
  #freqLabel { color: #00eaff; font-weight:600; margin-bottom:6px; }
  #freqSlider { width:100%; accent-color:#00eaff; margin-bottom:6px; }
  .small-muted { color:#9aa; font-size:0.9rem; }
</style>
</head>
<body class="min-h-screen bg-primary-bg text-text-light p-4">
<div class="container mx-auto">
  <h1 class="text-3xl font-extrabold mb-6 text-center" style="color:#00eaff;">Real-Time ECG Viewer</h1>
  <div class="row">
    <div class="col-md-3 sidebar">
      <h5>ECG Controls</h5>
      <form id="channelForm">
        <div class="mb-2">
          <label class="form-label">Speed (updates/sec)</label>
          <input id="speedControl" class="form-control" type="number" min="0.5" max="5" step="0.1" value="1" />
        </div>
        <div class="mb-2">
          <label class="form-label">Window width (seconds)</label>
          <input id="width" class="form-control" type="number" min="0.5" step="0.5" value="5"/>
        </div>
        <div class="mb-2">
          <label class="form-label">Select Channels</label>
          <div id="channelList" style="max-height:240px; overflow:auto;">Loading...</div>
        </div>
        <div class="mb-2">
          <label class="form-label">Upload .hea/.dat (drag & drop)</label>
          <div id="dropZone">Drop files here or <a href="#" id="pickFiles">choose files</a></div>
          <input id="filePicker" type="file" accept=".hea,.dat,.xyz" multiple style="display:none;" />
        </div>
        <div class="mb-2">
          <label class="form-label">Recurrence Colormap</label>
          <select id="colormapSelect" class="form-select">
            <option value="Jet">Jet</option>
            <option value="Viridis">Viridis</option>
            <option value="Hot">Hot</option>
            <option value="Rainbow">Rainbow</option>
          </select>
        </div>
        <div class="mb-2">
          <label class="form-label">Display</label>
          <select id="displaySelect" class="form-select">
            <option value="Time" selected>Time</option>
            <option value="XOR">XOR</option>
            <option value="Polar">Polar</option>
            <option value="Recurrence">Recurrence</option>
          </select>
        </div>

        <div class="mb-3">
          <label id="freqLabel" class="form-label">Sampling Frequency (Hz) <span id="freqValue" style="margin-left:8px;color:#9cf;">500 Hz</span></label>
          <input id="freqSlider" type="range" min="10" max="500" step="10" value="500" />
          <div style="display:flex; justify-content:space-between; align-items:center;">
            <div class="small-muted">Min:10</div>
            <div class="small-muted">Max: 500</div>
          </div>
          <div class="mt-2" style="display:flex; gap:8px;">
            <button id="applyFreq" class="btn btn-primary" type="button">Apply Sampling</button>
            <button id="resetFreq" class="btn btn-secondary" type="button">Reset Sampling</button>
          </div>
          <div class="form-text small-muted">Lower frequency simulates lower-sampling hardware — predictions & signal will change.</div>
        </div>

        <div class="prediction-box mb-3">
          <h6>Prediction</h6>
          <div id="predictionResult" class="prediction-result">Waiting for data...</div>
          <div id="predictionDescription" style="margin-top:8px; color:#ccc; font-size:0.9rem;"></div>
          <div id="recurrencePrediction" style="margin-top:6px; color:#90caf9; font-size:0.85rem;"></div>
          <div id="diseaseName" class="disease-name"></div>
          <div id="aliasingNote" style="margin-top:6px; color:#ffb74d; font-size:0.85rem;"></div>
        </div>
        <button class="btn btn-primary w-100" style="color:#e0e0e0;" type="submit">Start Streaming</button>
        <button id="stopBtn" class="btn btn-secondary w-100 mt-2" type="button">Stop</button>
      </form>
    </div>

    <div class="col-md-9">
      <!-- Time plot -->
      <div class="plot-container">
        <div id="timePlot" style="width:100%;height:550px;"></div>
      </div>

      <!-- XOR plot -->
      <div class="row">
        <div class="col-12 plot-container">
          <div style="display:flex; gap:12px; align-items:flex-start;">
            <div id="xorPlot" style="flex:1; width:100%; height:400px;"></div>
            <div style="width:220px;">
              <label class="form-label">XOR Threshold</label>
              <input id="xorThreshold" class="form-control" type="number" step="0.01" value="0.05" />
              <div class="form-text text-muted" style="color:#bbb;">Only show XOR when abs(curr - prev) &gt; threshold</div>
            </div>
          </div>
        </div>
      </div>

      <!-- Polar plot -->
      <div class="row">
        <div class="col-12 plot-container">
          <div style="display:flex; gap:12px; align-items:flex-start;">
            <div id="polarPlot" style="flex:1; width:100%; height:500px;"></div>
            <div style="width:220px;">
              <label class="form-label">Polar Mode</label>
              <select id="polarModeSelect" class="form-select">
                <option value="fixed">Fixed (current chunk)</option>
                <option value="cumulative">Cumulative</option>
              </select>
            </div>
          </div>
        </div>
      </div>

      <!-- Recurrence plot -->
      <div class="plot-container mt-3">
        <div id="recurrenceScatterPlot" style="width:100%;height:400px;"></div>
      </div>
    </div>
  </div>
</div>

<script>
let streaming=false, intervalId=null;
let updateSpeed=1, allChannels=[], selectedChannels=[], widthSec=5;
let nativeFs=500, displayFs=200;
let channelData={}, globalStart=0;
let colormap="Jet";
let polarMode = "fixed";
let currentDisplay = 'Time';
let filesUploaded = false;
let requestedSampling = null; // value applied via Apply Sampling

// Init config
async function initConfig(){
  try{
    const cfg = await fetch("/ecg/config").then(r=>r.json());
    nativeFs = cfg.fs_native || cfg.fs || nativeFs;
    displayFs = cfg.display_fs || displayFs;
    // Default UI to a safe cap of 500 Hz (or native if lower) so it doesn't show 1000 Hz by default
    requestedSampling = Math.min(500, nativeFs);
    const sliderEl = document.getElementById("freqSlider");
    sliderEl.max = Math.min(500, nativeFs);
    sliderEl.value = requestedSampling;
    document.getElementById("freqValue").innerText = requestedSampling + " Hz";
    allChannels = cfg.channels || (Array.from({length:12}, (_,i)=>"Lead "+(i+1)));
    const cdiv = document.getElementById("channelList");
    cdiv.innerHTML="";
    allChannels.forEach((name,i)=>{
      const checked=i<2?"checked":"";
      cdiv.insertAdjacentHTML("beforeend",
        `<div class="form-check">
          <input class="form-check-input channel-checkbox" type="checkbox" name="channels" value="${i}" ${checked}>
          <label class="form-check-label">${name}</label>
        </div>`
      );
    });
  }catch(e){ console.warn("Config fetch failed", e); }
}
initConfig();

// UI wiring
document.getElementById("colormapSelect").addEventListener("change",(ev)=>{ colormap=ev.target.value; });
document.getElementById("polarModeSelect").addEventListener("change", (ev)=>{ polarMode = ev.target.value; });
const xorThresholdInput = document.getElementById('xorThreshold');

const dropZone = document.getElementById('dropZone');
const filePicker = document.getElementById('filePicker');
document.getElementById('pickFiles').addEventListener('click', (e)=>{ e.preventDefault(); filePicker.click(); });

['dragenter','dragover','dragleave','drop'].forEach(evt => dropZone.addEventListener(evt, e=>e.preventDefault()));
dropZone.addEventListener('dragover', ()=> dropZone.style.borderColor = '#88cc88');
dropZone.addEventListener('dragleave', ()=> dropZone.style.borderColor = '#00eaff');
dropZone.addEventListener('drop', (e)=>{
  dropZone.style.borderColor='#00eaff';
  handleFiles(e.dataTransfer.files);
});
filePicker.addEventListener('change', (e)=> handleFiles(e.target.files));

function handleFiles(fileList){
  if(!fileList || fileList.length===0) return;
  const fd = new FormData();
  for(const f of fileList){ fd.append('files', f, f.name); }
  dropZone.innerText = 'Uploading...';
  fetch('/ecg/upload', { method:'POST', body: fd })
    .then(r=>r.json())
    .then(j=>{
      if(j && j.success){
        filesUploaded = true;
        dropZone.innerText = 'Upload successful';
        setTimeout(()=>{ initConfig(); dropZone.innerText = 'Drop files here or choose files'; }, 800);
      } else {
        filesUploaded = false;
        dropZone.innerText = 'Upload failed';
        alert('Upload failed: ' + (j && j.error ? j.error : JSON.stringify(j)));
        setTimeout(()=> dropZone.innerText = 'Drop files here or choose files', 1200);
      }
    }).catch(err=>{
      console.error(err);
      filesUploaded = false;
      dropZone.innerText = 'Upload error';
      setTimeout(()=> dropZone.innerText = 'Drop files here or choose files', 1200);
    });
}

// Display selection
const containers = {
  'Time': document.getElementById('timePlot').parentElement,
  'XOR': document.getElementById('xorPlot').parentElement,
  'Polar': document.getElementById('polarPlot').parentElement,
  'Recurrence': document.getElementById('recurrenceScatterPlot').parentElement
};
const displaySelect = document.getElementById('displaySelect');
function applyDisplaySelection(val){
  currentDisplay = val;
  const sizes = {'Time':'550px','XOR':'400px','Polar':'600px','Recurrence':'600px'};
  Object.keys(containers).forEach(k=>{
    const plotId = (k==='Time')?'timePlot':(k==='XOR')?'xorPlot':(k==='Polar')?'polarPlot':'recurrenceScatterPlot';
    const plotDiv = document.getElementById(plotId);
    if(k===currentDisplay){
      containers[k].style.display='block';
      if(plotDiv) plotDiv.style.height=sizes[k]||'500px';
      try{ if(plotDiv) Plotly.relayout(plotId,{height:parseInt(sizes[k]||'500px')}); }catch(e){}
    } else { containers[k].style.display='none'; }
  });
}
displaySelect.addEventListener('change', (e)=> applyDisplaySelection(e.target.value));
applyDisplaySelection(displaySelect.value || 'Time');

// Frequency slider
const freqSlider = document.getElementById('freqSlider');
const freqValue = document.getElementById('freqValue');
freqSlider.addEventListener('input', (e)=>{
  freqValue.innerText = e.target.value + " Hz";
});
document.getElementById('applyFreq').addEventListener('click', async ()=>{
  const val = parseFloat(freqSlider.value);
  // call backend to set sampling (clears buffers so model will predict freshly)
  const res = await fetch('/ecg/set_sampling', {
    method:'POST', headers:{'Content-Type':'application/json'},
    body: JSON.stringify({sampling_freq: val})
  });
  const j = await res.json();
  if(j && j.success){
    requestedSampling = j.current_sampling;
    alert("Applied sampling: " + requestedSampling + " Hz.");
    // If streaming, fetch new data without resetting buffers
    if(streaming){ await fetchData(); }
  } else {
    alert("Failed to apply sampling: " + JSON.stringify(j));
  }
});
document.getElementById('resetFreq').addEventListener('click', async ()=>{
  const res = await fetch('/ecg/reset_sampling',{method:'POST'});
  const j = await res.json();
  if(j && j.success){
    requestedSampling = j.current_sampling;
    freqSlider.value = requestedSampling;
    freqValue.innerText = requestedSampling + " Hz";
    alert("Reset sampling to native: " + requestedSampling + " Hz");
  } else {
    alert("Failed to reset sampling: " + JSON.stringify(j));
  }
});

// Form submit (start)
document.getElementById("channelForm").addEventListener("submit", ev=>{
  ev.preventDefault();
  if(!filesUploaded){ alert("Please upload files first."); return; }
  selectedChannels = Array.from(document.querySelectorAll("input[name=channels]:checked")).map(n=>parseInt(n.value));
  widthSec = parseFloat(document.getElementById("width").value)||5;
  updateSpeed = parseFloat(document.getElementById("speedControl").value)||1;
  if(selectedChannels.length===0){ alert("Select channel(s)"); return; }

  channelData={}; globalStart=0;
  selectedChannels.forEach(ch=>channelData[ch]=[]);
  initPlots(selectedChannels);
  streaming=true;
  if(intervalId) clearInterval(intervalId);
  intervalId=setInterval(fetchData,1000/updateSpeed);
});

document.getElementById("stopBtn").addEventListener("click", ()=>{
  streaming=false;
  if(intervalId) clearInterval(intervalId);
});

// Update speed change
document.getElementById("speedControl").addEventListener("change", ev=>{
  updateSpeed = parseFloat(ev.target.value)||1;
  if(streaming){
    if(intervalId) clearInterval(intervalId);
    intervalId=setInterval(fetchData,1000/updateSpeed);
  }
});

function initPlots(channels){
  if(!filesUploaded) return;
  const timeTraces = channels.map(ch=>({x:[],y:[],mode:"lines",name:"",line:{width:1.8}, showlegend:false, hoverinfo:'none'}));
  Plotly.newPlot("timePlot", timeTraces, {
    title:'Real-time ECG (time domain)',
    paper_bgcolor:"#000", plot_bgcolor:"#000", font:{color:"#e0e0e0"},
    xaxis:{title:"Time (s)", range:[0,widthSec], gridcolor:"#333", dtick:2},
    yaxis:{title:"Amplitude", gridcolor:"#333", autorange:true},
    showlegend:false
  });

  if(channels.length===1){
    Plotly.newPlot("xorPlot", [{x:[],y:[],mode:"lines",showlegend:false,hoverinfo:'none'}],
      {title:'XOR Graph', paper_bgcolor:"#000", plot_bgcolor:"#000", font:{color:"#e0e0e0"}, showlegend:false});
  }

  const polarTraces = channels.map(ch=>({r:[],theta:[],mode:"lines",type:"scatterpolar",name:"",showlegend:false,hoverinfo:'none'}));
  Plotly.newPlot("polarPlot", polarTraces, {title:'Polar Plot', paper_bgcolor:"#000", font:{color:"#e0e0e0"}, showlegend:false});

  if(channels.length===2){
    Plotly.newPlot("recurrenceScatterPlot", [{ z:[], type:"heatmap", colorscale:colormap }], {title:'Recurrence', paper_bgcolor:"#000", plot_bgcolor:"#000", font:{color:"#e0e0e0"}, showlegend:false});
  } else {
    // keep plot but empty
    Plotly.purge('recurrenceScatterPlot');
    document.getElementById('recurrenceScatterPlot').innerHTML = '';
  }
}

async function fetchData(){
  if(!streaming) return;
  try{
    const xorThresholdVal = xorThresholdInput ? parseFloat(xorThresholdInput.value)||0.05 : 0.05;
    // when calling update, send channels + current requestedSampling (backend will clamp to native)
    const resp = await fetch("/ecg/update", {
      method:"POST",
      headers:{"Content-Type":"application/json"},
      body:JSON.stringify({channels:selectedChannels, width:widthSec, polar_mode:polarMode, xor_threshold:xorThresholdVal, sampling_freq: requestedSampling})
    });
    if(!resp.ok) throw new Error("HTTP "+resp.status);
    const result = await resp.json();
    const plotFs = result.display_fs || displayFs;
    const usedFs = result.used_sampling_freq || requestedSampling || nativeFs;
    const maxSamples=Math.round(widthSec*plotFs*4); // Keep 4x window width to reduce compression

    // Keep the label in sync with backend-reported sampling
    document.getElementById('freqValue').innerText = usedFs + ' Hz';
    selectedChannels.forEach((ch,idx)=>{
      const chunk=result.signals[String(ch)]||[];
      channelData[ch].push(...chunk);
      // Trim data more gradually to reduce compression
      if(channelData[ch].length>maxSamples){
        const drop=Math.floor(channelData[ch].length*0.1); // Only drop 10% at a time
        channelData[ch]=channelData[ch].slice(drop);
        if(idx===0) globalStart+=drop/plotFs;
      }
      const xvals=channelData[ch].map((_,i)=>globalStart+i/plotFs);
      if(currentDisplay==='All'||currentDisplay==='Time') Plotly.restyle("timePlot",{x:[xvals],y:[channelData[ch]]},[idx]);
    });
    // Set a fixed time window that slides with the data
    const currentTime = globalStart + (channelData[selectedChannels[0]]?.length || 0) / plotFs;
    Plotly.relayout("timePlot",{"xaxis.range":[Math.max(0, currentTime-widthSec), currentTime], "xaxis.dtick":0.5});

    if(selectedChannels.length===1){
      const chXOR=selectedChannels[0];
      const xorChunk=result.xor[String(chXOR)]||[];
      const xvalsXOR=xorChunk.map((_,i)=>globalStart+i/plotFs);
      if(currentDisplay==='All'||currentDisplay==='XOR'){
        Plotly.restyle("xorPlot",{x:[xvalsXOR],y:[xorChunk]},[0]);
        if(xvalsXOR.length>0){
          const xMin=xvalsXOR[0], xMax=xvalsXOR[xvalsXOR.length-1];
          let yMin=0,yMax=0;
          if(xorChunk.length>0){ yMin=Math.min(...xorChunk)-0.01; yMax=Math.max(...xorChunk)+0.01; }
          Plotly.relayout("xorPlot", {"xaxis.range":[xMin,xMax], "yaxis.range":[yMin,yMax]});
        }
      }
    }

    const rArr=[], thetaArr=[];
    selectedChannels.forEach(ch=>{
      const polar=result.polar[String(ch)]||{r:[],theta:[]};
      rArr.push(polar.r); thetaArr.push(polar.theta);
    });
    if(currentDisplay==='All'||currentDisplay==='Polar') Plotly.restyle("polarPlot",{r:rArr,theta:thetaArr});

    if(selectedChannels.length===2){
      const colormapData=result.colormap||[];
      if(currentDisplay==='All'||currentDisplay==='Recurrence') {
        try {
          Plotly.restyle("recurrenceScatterPlot",{z:[colormapData], colorscale:colormap});
        } catch(e){}
      }
    }

    // prediction UI
    if(filesUploaded){
      const pred=result.prediction||{};
      const rec=result.recurrence_prediction||{};
      const alias=result.aliasing||{};
      const predRes=document.getElementById("predictionResult");
      const predDesc=document.getElementById("predictionDescription");
      const recEl=document.getElementById("recurrencePrediction");
      const diseaseEl=document.getElementById("diseaseName");
      const aliasEl=document.getElementById("aliasingNote");

      let disp=(pred&&typeof pred==='object')?(pred.smoothed||pred.raw||pred):null;
      if(!disp||!disp.label){
        predRes.innerText="N/A";
        predDesc.innerText="";
        diseaseEl.innerText="";
      }else{
        predRes.innerText=disp.label||"N/A";
        predDesc.innerText=disp.description||"";
        diseaseEl.innerText=disp.disease_name||"";
      }

      if(rec&&rec.label){
        const conf=rec.confidence!==undefined?` (Confidence: ${(rec.confidence*100).toFixed(1)}%)`:"";
        recEl.innerText=`Recurrence Prediction: ${rec.label}${conf}`;
      }else{
        recEl.innerText="";
      }

      if(alias && alias.is_undersampled){
        aliasEl.innerText = alias.note || "Potential aliasing detected at current sampling.";
        aliasEl.style.color = "#ff6b6b";
        aliasEl.style.fontWeight = "bold";
      } else {
        aliasEl.innerText = "";
      }
    }

  }catch(err){
    console.error(err);
    streaming=false;
    if(intervalId) clearInterval(intervalId);
    alert("Connection lost or server error — check console.");
  }
}
</script>
</body>
</html>
