<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ECG Real-Time Viewer</title>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css"/>
  <style>
    body {
      background:#000;
      color:#e0e0e0;
      font-family: Inter, sans-serif;
    }
    .sidebar {
      background:#1e1e1e;
      padding:18px;
      border-radius:10px;
    }
    .plot-container {
      background:#111;
      padding:12px;
      border-radius:10px;
      margin-bottom:16px;
    }
    .prediction-box {
      background:#111;
      padding:12px;
      border-radius:10px;
      text-align:center;
    }
    .prediction-result {
      font-weight:700;
      color:#00ff88;
    }
    .disease-name {
      color:#ff6666;
      font-weight:600;
      margin-top:6px;
    }
  </style>
</head>
<body class="container-fluid p-4">
  <div class="row">
    <div class="col-md-3 sidebar">
      <h5>ECG Controls</h5>
      <form id="channelForm">
        <div class="mb-2">
          <label class="form-label">Window width (seconds)</label>
          <input id="width" class="form-control bg-dark text-white" type="number" min="0.5" step="0.5" value="5"/>
        </div>
        <div class="mb-2">
          <label class="form-label">Select Channels</label>
          <div id="channelList" style="max-height:240px; overflow:auto;">Loading...</div>
        </div>
        <div class="mb-2">
          <label class="form-label">Recurrence Colormap</label>
          <select id="colormapSelect" class="form-select bg-dark text-white">
            <option value="Jet">Jet</option>
            <option value="Viridis">Viridis</option>
            <option value="Hot">Hot</option>
            <option value="Rainbow">Rainbow</option>
          </select>
        </div>
        <button class="btn btn-primary w-100" type="submit">Start Streaming</button>
        <button id="stopBtn" class="btn btn-secondary w-100 mt-2" type="button">Stop</button>
      </form>
    </div>
    <div class="col-md-9">
      <div class="plot-container">
        <h5>Real-time ECG (time domain)</h5>
        <div id="timePlot" style="width:100%;height:300px;"></div>
      </div>
      <div class="row">
        <div class="col-md-6 plot-container">
          <h5>XOR Graph (1 channel only, cumulative)</h5>
          <div id="xorPlot" style="width:100%;height:300px;"></div>
        </div>
        <div class="col-md-6 plot-container">
          <h5>Polar Plot</h5>
          <div id="polarPlot" style="width:100%;height:300px;"></div>
        </div>
      </div>
      <div class="plot-container mt-3">
        <h5>Recurrence 2D Scatter / Colormap (first 2 channels)</h5>
        <div id="recurrenceScatterPlot" style="width:100%;height:300px;"></div>
      </div>
      <div class="prediction-box mt-3">
        <h5>Prediction</h5>
        <div id="predictionResult" class="prediction-result">Waiting for data...</div>
        <div id="predictionDescription" style="margin-top:8px; color:#ccc; font-size:0.95rem;"></div>
        <div id="diseaseName" class="disease-name"></div>
      </div>
    </div>
  </div>

<script>
let streaming=false, intervalId=null;
let allChannels=[], selectedChannels=[], widthSec=5;
let fs=360, displayFs=200;
let channelData={}, globalStart=0;
let colormap="Jet";

async function initConfig(){
  try{
    const cfg = await fetch("/ecg/config").then(r=>r.json());
    fs = cfg.fs || fs;
    displayFs = cfg.display_fs || displayFs;
    allChannels = cfg.channels || [];
    const cdiv = document.getElementById("channelList");
    cdiv.innerHTML="";
    allChannels.forEach((name,i)=>{
      const checked=i<2?"checked":"";
      cdiv.insertAdjacentHTML("beforeend",
        `<div class="form-check">
          <input class="form-check-input" type="checkbox" name="channels" value="${i}" ${checked}>
          <label class="form-check-label">${name}</label>
        </div>`
      );
    });
  }catch(e){ console.warn("Config fetch failed", e); }
}
initConfig();

document.getElementById("colormapSelect").addEventListener("change",(ev)=>{ colormap=ev.target.value; });

document.getElementById("channelForm").addEventListener("submit", ev=>{
  ev.preventDefault();
  selectedChannels=Array.from(document.querySelectorAll("input[name=channels]:checked")).map(n=>parseInt(n.value));
  widthSec=parseFloat(document.getElementById("width").value)||5;
  if(selectedChannels.length===0){ alert("Select channel(s)"); return; }

  if(selectedChannels.length===1 || selectedChannels.length===2){
    channelData={};
    globalStart=0;
    selectedChannels.forEach(ch=>channelData[ch]=[]);
    initPlots(selectedChannels);
    streaming=true;
    if(intervalId) clearInterval(intervalId);
    intervalId=setInterval(fetchData,900);
  } else {
    alert("XOR: 1 channel only; Recurrence: 2 channels only.");
  }
});

document.getElementById("stopBtn").addEventListener("click", ()=>{
  streaming=false;
  if(intervalId) clearInterval(intervalId);
});

function initPlots(channels){
  const timeTraces=channels.map(ch=>({x:[],y:[],mode:"lines",name:allChannels[ch],line:{width:1.5}}));
  Plotly.newPlot("timePlot",timeTraces,{
    paper_bgcolor:"#000", plot_bgcolor:"#000", font:{color:"#e0e0e0"},
    xaxis:{title:"Time (s)", range:[0,widthSec], gridcolor:"#333"},
    yaxis:{title:"Amplitude", gridcolor:"#333"}
  });

  // XOR plot: only if 1 channel
  if(channels.length===1){
    const xorTraces=[{x:[],y:[],mode:"lines",name:`XOR ${allChannels[channels[0]]}`}];
    Plotly.newPlot("xorPlot",xorTraces,{
      paper_bgcolor:"#000", plot_bgcolor:"#000", font:{color:"#e0e0e0"},
      xaxis:{title:"Time (s)", range:[0,widthSec*4]},
      yaxis:{title:"XOR Amplitude"}
    });
  }

  const polarTraces=channels.map(ch=>({r:[],theta:[],mode:"lines",type:"scatterpolar",name:allChannels[ch]}));
  Plotly.newPlot("polarPlot",polarTraces,{paper_bgcolor:"#000",font:{color:"#e0e0e0"}});

  // Recurrence: only if 2 channels
  if(channels.length===2){
    Plotly.newPlot("recurrenceScatterPlot",[{ z: [], type: "heatmap", colorscale: colormap }],
      {paper_bgcolor:"#000", plot_bgcolor:"#000", font:{color:"#e0e0e0"}});
  }
}

async function fetchData(){
  if(!streaming) return;
  try{
    const resp=await fetch("/ecg/update",{
      method:"POST",
      headers:{"Content-Type":"application/json"},
      body:JSON.stringify({channels:selectedChannels,width:widthSec})
    });
    if(!resp.ok) throw new Error("HTTP "+resp.status);
    const result=await resp.json();
    const plotFs=displayFs, maxSamples=Math.round(widthSec*plotFs);

    selectedChannels.forEach((ch,idx)=>{
      const chunk=result.signals[String(ch)]||[];
      channelData[ch].push(...chunk);
      if(channelData[ch].length>maxSamples){
        const drop=channelData[ch].length-maxSamples;
        channelData[ch]=channelData[ch].slice(drop);
        if(idx===0) globalStart+=drop/plotFs;
      }
      const xvals=channelData[ch].map((_,i)=>globalStart+i/plotFs);
      Plotly.restyle("timePlot",{x:[xvals],y:[channelData[ch]]},[idx]);
    });
    Plotly.relayout("timePlot",{"xaxis.range":[globalStart,globalStart+widthSec]});

    // XOR: only for 1 channel
    if(selectedChannels.length===1){
      const chXOR = selectedChannels[0];
      const xorChunk = result.xor[String(chXOR)] || [];
      const xvalsXOR = xorChunk.map((_, i) => globalStart + i / plotFs);
      const xMin = xvalsXOR[0], xMax = xvalsXOR[xvalsXOR.length - 1];
      const yMin = Math.min(...xorChunk)-0.1, yMax = Math.max(...xorChunk)+0.1;
      Plotly.restyle("xorPlot", { x: [xvalsXOR], y: [xorChunk] }, [0]);
      Plotly.relayout("xorPlot", { "xaxis.range": [xMin, xMax], "yaxis.range": [yMin, yMax] });
    }

    const rArr=[],thetaArr=[];
    selectedChannels.forEach(ch=>{
      const polar=result.polar[String(ch)]||{r:[],theta:[]};
      rArr.push(polar.r);
      thetaArr.push(polar.theta);
    });
    Plotly.restyle("polarPlot",{r:rArr,theta:thetaArr});

    // Recurrence: only for 2 channels
    if(selectedChannels.length===2){
      const colormapData=result.colormap||[];
      Plotly.restyle("recurrenceScatterPlot",{z:[colormapData], colorscale: colormap});
    }

    // Prediction
    const pred=result.prediction||{};
    document.getElementById("predictionResult").innerText = pred.label||"N/A";
    document.getElementById("predictionDescription").innerText = pred.description||"";
    document.getElementById("diseaseName").innerText = pred.disease_name||"";

  }catch(err){
    console.error(err);
    streaming=false;
    if(intervalId) clearInterval(intervalId);
    alert("Connection lost or server error â€” check console.");
  }
}
</script>
</body>
</html>
