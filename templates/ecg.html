<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Real-Time ECG Viewer</title>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css"/>
<style>
  /* General body and sidebar */
  body {
    background: #000;
    color: #e0e0e0;
    font-family: Inter, sans-serif;
  }

  .sidebar {
    background: #030000;
    padding: 18px;
    border-radius: 10px;
    max-height: 95vh;
    overflow-y: auto; /* scrollable sidebar */
  }

  .plot-container {
    background: #000000;
    padding: 12px;
    border-radius: 10px;
    margin-bottom: 16px;
  }

  .prediction-box {
    background: #111;
    padding: 12px;
    border-radius: 10px;
    text-align: center;
  }

  .prediction-result {
    font-weight: 700;
    color: #00f7ff;
  }

  .disease-name {
    color: #ca1414;
    font-weight: 600;
    margin-top: 6px;
  }

  /* Buttons */
  .btn-primary {
    background: #000000;
    border: 1px solid#00f7ff;
    font-weight: 600;
  }
  
  .btn-primary:hover {
    background: #323739;
    border-color: #00e1ff;
    color: #000;
  }
  .btn-primary {
    --bs-btn-color: #fff;
    --bs-btn-bg: #00e1ff;
    --bs-btn-border-color: #00e1ff;
    --bs-btn-hover-color: #fff;
    --bs-btn-hover-bg: #00e1ff;
    --bs-btn-hover-border-color: #00e1ff;
    --bs-btn-focus-shadow-rgb: 49, 132, 253;
    --bs-btn-active-color: #fff;
    --bs-btn-active-bg: #303636;
    --bs-btn-active-border-color: #00e1ff;
    --bs-btn-active-shadow: inset 0 3px 5px rgba(0, 0, 0, 0.125);
    --bs-btn-disabled-color: #fff;
    --bs-btn-disabled-bg: #202829;
    --bs-btn-disabled-border-color: #00e1ff;
}

  .btn-secondary {
    background: #333;
    border: 1px solid #00f2ff;
    color: #00ffe5;
  }
  .btn-secondary:hover {
    background: #444;
    border-color: #00eeff;
    color: #00fbff;
  }

  /* Drop zone */
  #dropZone {
    border: 2px dashed #00f7ff;
    padding: 12px;
    border-radius: 8px;
    background: #0e0e0e;
    color: #ccc;
    text-align: center;
  }
  #pickFiles {
    color:#00f7ff;
    text-decoration: underline;
    cursor: pointer;
  }
  #pickFiles:hover {
    color: #ccddd7;
  }

  /* Form inputs and selects */
  input.form-control, select.form-select {
    background: #222;
    color: #00f7ff;
    border: 1px solid #00f7ff;
  }

  input.form-control:focus, select.form-select:focus {
    border-color: #00f7ff;
    box-shadow: 0 0 8px #00f7ff;
  }

  /* Labels */
  label.form-label {
    color:#00f7ff;
    font-weight: 500;
  }

  .form-check-label {
    color: #ccc;
  }
  

.form-check-input:checked {
    background-color: #101112;
    border-color: #00f7ff;
}

  .form-text {
    color: #888;
  }

  /* Heading */
  h1 {
    color: #00f7ff;
    text-align: center;
    font-weight: 800;
    margin-bottom: 24px;
  }
</style>
</head>
<body class="min-h-screen bg-primary-bg text-text-light p-4">
<div class="container mx-auto">
  <h1 class="text-3xl font-extrabold mb-6 text-center" style="color:#00eaff;">Real-Time ECG Viewer</h1>
  <div class="row">
    <div class="col-md-3 sidebar">
      <h5>ECG Controls</h5>
      <form id="channelForm">
        <div class="mb-2">
          <label class="form-label">Speed (updates/sec)</label>
          <input id="speedControl" class="form-control" type="number" min="0.5" max="5" step="0.1" value="1" />
        </div>
        <div class="mb-2">
          <label class="form-label">Window width (seconds)</label>
          <input id="width" class="form-control" type="number" min="0.5" step="0.5" value="5"/>
        </div>
        <div class="mb-2">
          <label class="form-label">Select Channels</label>
          <div id="channelList" style="max-height:240px; overflow:auto;">Loading...</div>
        </div>
        <div class="mb-2">
          <label class="form-label">Upload .hea/.dat (drag & drop)</label>
          <div id="dropZone">Drop files here or <a href="#" id="pickFiles">choose files</a></div>
          <input id="filePicker" type="file" accept=".hea,.dat,.xyz" multiple style="display:none;" />
        </div>
        <div class="mb-2">
          <label class="form-label">Recurrence Colormap</label>
          <select id="colormapSelect" class="form-select">
            <option value="Jet">Jet</option>
            <option value="Viridis">Viridis</option>
            <option value="Hot">Hot</option>
            <option value="Rainbow">Rainbow</option>
          </select>
        </div>
        <div class="mb-2">
          <label class="form-label">Display</label>
          <select id="displaySelect" class="form-select">
            <option value="Time" selected>Time</option>
            <option value="XOR">XOR</option>
            <option value="Polar">Polar</option>
            <option value="Recurrence">Recurrence</option>
          </select>
        </div>
        <div class="prediction-box mb-3">
          <h6>Prediction</h6>
          <div id="predictionResult" class="prediction-result">Waiting for data...</div>
          <div id="predictionDescription" style="margin-top:8px; color:#ccc; font-size:0.9rem;"></div>
          <div id="recurrencePrediction" class="text-info" style="margin-top:8px; font-size:0.9rem;"></div>
          <div id="diseaseName" class="disease-name"></div>
        </div>
        <button class="btn btn-primary w-100" style="color:#00eaff;" type="submit">Start Streaming</button>
        <button id="stopBtn" class="btn btn-secondary w-100 mt-2" type="button">Stop</button>
      </form>
    </div>

    <div class="col-md-9">
      <!-- Time plot -->
      <div class="plot-container">
        <div id="timePlot" style="width:100%;height:550px;"></div>
      </div>

      <!-- XOR plot -->
      <div class="row">
        <div class="col-12 plot-container">
          <div style="display:flex; gap:12px; align-items:flex-start;">
            <div id="xorPlot" style="flex:1; width:100%; height:400px;"></div>
            <div style="width:220px;">
              <label class="form-label">XOR Threshold</label>
              <input id="xorThreshold" class="form-control" type="number" step="0.01" value="0.05" />
              <div class="form-text text-muted" style="color:#bbb;">Only show XOR when abs(curr - prev) &gt; threshold</div>
            </div>
          </div>
        </div>
      </div>

      <!-- Polar plot -->
      <div class="row">
        <div class="col-12 plot-container">
          <div style="display:flex; gap:12px; align-items:flex-start;">
            <div id="polarPlot" style="flex:1; width:100%; height:500px;"></div>
            <div style="width:220px;">
              <label class="form-label">Polar Mode</label>
              <select id="polarModeSelect" class="form-select">
                <option value="fixed">Fixed (current chunk)</option>
                <option value="cumulative">Cumulative</option>
              </select>
            </div>
          </div>
        </div>
      </div>

      <!-- Recurrence plot -->
      <div class="plot-container mt-3">
        <div id="recurrenceScatterPlot" style="width:100%;height:400px;"></div>
      </div>
    </div>
  </div>
</div>

<script>
let streaming=false, intervalId=null;
let updateSpeed=1, allChannels=[], selectedChannels=[], widthSec=5;
let fs=360, displayFs=200;
let channelData={}, globalStart=0;
let colormap="Jet";
let polarMode = "fixed";
let currentDisplay = 'All';
let filesUploaded = false;

// Initialize channel config
async function initConfig(){
  try{
    const cfg = await fetch("/ecg/config").then(r=>r.json());
    fs = cfg.fs || fs;
    displayFs = cfg.display_fs || displayFs;
    allChannels = cfg.channels || [];
    const cdiv = document.getElementById("channelList");
    cdiv.innerHTML="";
    allChannels.forEach((name,i)=>{
      const checked=i<2?"checked":"";
      cdiv.insertAdjacentHTML("beforeend",
        `<div class="form-check">
          <input class="form-check-input" type="checkbox" name="channels" value="${i}" ${checked}>
          <label class="form-check-label">${name}</label>
        </div>`
      );
    });
  }catch(e){ console.warn("Config fetch failed", e); }
}
initConfig();

// Event listeners
document.getElementById("colormapSelect").addEventListener("change",(ev)=>{ colormap=ev.target.value; });
document.getElementById("polarModeSelect").addEventListener("change", (ev)=>{ polarMode = ev.target.value; });
const xorThresholdInput = document.getElementById('xorThreshold');

const dropZone = document.getElementById('dropZone');
const filePicker = document.getElementById('filePicker');
document.getElementById('pickFiles').addEventListener('click', (e)=>{ e.preventDefault(); filePicker.click(); });

['dragenter','dragover','dragleave','drop'].forEach(evt => dropZone.addEventListener(evt, e=>e.preventDefault()));
dropZone.addEventListener('dragover', ()=> dropZone.style.borderColor = '#88cc88');
dropZone.addEventListener('dragleave', ()=> dropZone.style.borderColor = '#00eaff');
dropZone.addEventListener('drop', (e)=>{
  dropZone.style.borderColor='#00eaff';
  handleFiles(e.dataTransfer.files);
});
filePicker.addEventListener('change', (e)=> handleFiles(e.target.files));

function handleFiles(fileList){
  if(!fileList || fileList.length===0) return;
  const fd = new FormData();
  for(const f of fileList){ fd.append('files', f, f.name); }
  dropZone.innerText = 'Uploading...';
  fetch('/ecg/upload', { method:'POST', body: fd })
    .then(r=>r.json())
    .then(j=>{
      if(j && j.success){
        filesUploaded = true;
        dropZone.innerText = 'Upload successful';
        setTimeout(()=>{ initConfig(); dropZone.innerText = 'Drop files here or choose files'; }, 800);
      } else {
        filesUploaded = false;
        dropZone.innerText = 'Upload failed';
        alert('Upload failed: ' + (j && j.error ? j.error : JSON.stringify(j)));
        setTimeout(()=> dropZone.innerText = 'Drop files here or choose files', 1200);
      }
    }).catch(err=>{
      console.error(err);
      filesUploaded = false;
      dropZone.innerText = 'Upload error';
      setTimeout(()=> dropZone.innerText = 'Drop files here or choose files', 1200);
    });
}

// Display selection
const containers = {
  'Time': document.getElementById('timePlot').parentElement,
  'XOR': document.getElementById('xorPlot').parentElement,
  'Polar': document.getElementById('polarPlot').parentElement,
  'Recurrence': document.getElementById('recurrenceScatterPlot').parentElement
};
const displaySelect = document.getElementById('displaySelect');
function applyDisplaySelection(val){
  currentDisplay = val;
  const sizes = {'Time':'550px','XOR':'400px','Polar':'600px','Recurrence':'600px'};
  Object.keys(containers).forEach(k=>{
    const plotId = (k==='Time')?'timePlot':(k==='XOR')?'xorPlot':(k==='Polar')?'polarPlot':'recurrenceScatterPlot';
    const plotDiv = document.getElementById(plotId);
    if(k===currentDisplay){
      containers[k].style.display='block';
      if(plotDiv) plotDiv.style.height=sizes[k]||'500px';
      try{ if(plotDiv) Plotly.relayout(plotId,{height:parseInt(sizes[k]||'500px')}); }catch(e){}
    } else { containers[k].style.display='none'; }
  });
}
displaySelect.addEventListener('change', (e)=> applyDisplaySelection(e.target.value));
applyDisplaySelection(displaySelect.value || 'Time');

// Form submit
document.getElementById("channelForm").addEventListener("submit", ev=>{
  ev.preventDefault();
  if(!filesUploaded){ alert("Please upload files first."); return; }
  selectedChannels = Array.from(document.querySelectorAll("input[name=channels]:checked")).map(n=>parseInt(n.value));
  widthSec = parseFloat(document.getElementById("width").value)||5;
  updateSpeed = parseFloat(document.getElementById("speedControl").value)||1;
  if(selectedChannels.length===0){ alert("Select channel(s)"); return; }

  channelData={}; globalStart=0;
  selectedChannels.forEach(ch=>channelData[ch]=[]);
  initPlots(selectedChannels);
  streaming=true;
  if(intervalId) clearInterval(intervalId);
  intervalId=setInterval(fetchData,1000/updateSpeed);
});

document.getElementById("stopBtn").addEventListener("click", ()=>{
  streaming=false;
  if(intervalId) clearInterval(intervalId);
});

document.getElementById("speedControl").addEventListener("change", ev=>{
  updateSpeed = parseFloat(ev.target.value)||1;
  if(streaming){
    if(intervalId) clearInterval(intervalId);
    intervalId=setInterval(fetchData,1000/updateSpeed);
  }
});

function initPlots(channels){
  if(!filesUploaded) return; // do not init unless files uploaded
  const timeTraces = channels.map(ch=>({x:[],y:[],mode:"lines",name:"",line:{width:1.5}, showlegend:false, hoverinfo:'none'}));
  Plotly.newPlot("timePlot", timeTraces, {
    title:'Real-time ECG (time domain)',
    paper_bgcolor:"#000", plot_bgcolor:"#000", font:{color:"#e0e0e0"},
    xaxis:{title:"Time (s)", range:[0,widthSec], gridcolor:"#333"},
    yaxis:{title:"Amplitude", gridcolor:"#333", autorange:true},
    showlegend:false
  });

  if(channels.length===1){
    Plotly.newPlot("xorPlot", [{x:[],y:[],mode:"lines",showlegend:false,hoverinfo:'none'}],
      {title:'XOR Graph', paper_bgcolor:"#000", plot_bgcolor:"#000", font:{color:"#e0e0e0"}, showlegend:false});
  }

  const polarTraces = channels.map(ch=>({r:[],theta:[],mode:"lines",type:"scatterpolar",name:"",showlegend:false,hoverinfo:'none'}));
  Plotly.newPlot("polarPlot", polarTraces, {title:'Polar Plot', paper_bgcolor:"#000", font:{color:"#e0e0e0"}, showlegend:false});

  if(channels.length===2){
    Plotly.newPlot("recurrenceScatterPlot", [{ z:[], type:"heatmap", colorscale:colormap }],
      {title:'Recurrence', paper_bgcolor:"#000", plot_bgcolor:"#000", font:{color:"#e0e0e0"}, showlegend:false});
  }
}

async function fetchData(){
  if(!streaming) return;
  try{
    const xorThresholdVal = xorThresholdInput ? parseFloat(xorThresholdInput.value)||0.05 : 0.05;
    const resp = await fetch("/ecg/update", {
      method:"POST",
      headers:{"Content-Type":"application/json"},
      body:JSON.stringify({channels:selectedChannels,width:widthSec, polar_mode:polarMode, xor_threshold:xorThresholdVal})
    });
    if(!resp.ok) throw new Error("HTTP "+resp.status);
    const result = await resp.json();
    const plotFs = displayFs, maxSamples=Math.round(widthSec*plotFs);

    selectedChannels.forEach((ch,idx)=>{
      const chunk=result.signals[String(ch)]||[];
      channelData[ch].push(...chunk);
      if(channelData[ch].length>maxSamples){
        const drop=channelData[ch].length-maxSamples;
        channelData[ch]=channelData[ch].slice(drop);
        if(idx===0) globalStart+=drop/plotFs;
      }
      const xvals=channelData[ch].map((_,i)=>globalStart+i/plotFs);
      if(currentDisplay==='All'||currentDisplay==='Time') Plotly.restyle("timePlot",{x:[xvals],y:[channelData[ch]]},[idx]);
    });
    Plotly.relayout("timePlot",{"xaxis.range":[globalStart,globalStart+widthSec]});

    if(selectedChannels.length===1){
      const chXOR=selectedChannels[0];
      const xorChunk=result.xor[String(chXOR)]||[];
      const xvalsXOR=xorChunk.map((_,i)=>globalStart+i/plotFs);
      if(currentDisplay==='All'||currentDisplay==='XOR'){
        Plotly.restyle("xorPlot",{x:[xvalsXOR],y:[xorChunk]},[0]);
        if(xvalsXOR.length>0){
          const xMin=xvalsXOR[0], xMax=xvalsXOR[xvalsXOR.length-1];
          let yMin=0,yMax=0;
          if(xorChunk.length>0){ yMin=Math.min(...xorChunk)-0.01; yMax=Math.max(...xorChunk)+0.01; }
          Plotly.relayout("xorPlot", {"xaxis.range":[xMin,xMax], "yaxis.range":[yMin,yMax]});
        }
      }
    }

    const rArr=[], thetaArr=[];
    selectedChannels.forEach(ch=>{
      const polar=result.polar[String(ch)]||{r:[],theta:[]};
      rArr.push(polar.r); thetaArr.push(polar.theta);
    });
    if(currentDisplay==='All'||currentDisplay==='Polar') Plotly.restyle("polarPlot",{r:rArr,theta:thetaArr});

    if(selectedChannels.length===2){
      const colormapData=result.colormap||[];
      if(currentDisplay==='All'||currentDisplay==='Recurrence') Plotly.restyle("recurrenceScatterPlot",{z:[colormapData], colorscale:colormap});
    }

   // === Restored + clearer prediction logic ===
if(filesUploaded){
  const pred=result.prediction||{};
  const rec=result.recurrence_prediction||{};
  const predRes=document.getElementById("predictionResult");
  const predDesc=document.getElementById("predictionDescription");
  const recEl=document.getElementById("recurrencePrediction");
  const diseaseEl=document.getElementById("diseaseName");

  // --- Normal ECG prediction ---
  let disp=(pred&&typeof pred==='object')?(pred.smoothed||pred.raw||pred):null;
  if(!disp||!disp.label){
    predRes.innerText="N/A";
    predDesc.innerText="";
    diseaseEl.innerText="";
  }else{
    predRes.innerText=disp.label||"N/A";
    predDesc.innerText=disp.description||"";
    diseaseEl.innerText=disp.disease_name||"";
  }

  // --- Recurrence prediction ---
  if(rec&&rec.label){
    const conf=rec.confidence!==undefined?` (Confidence: ${(rec.confidence*100).toFixed(1)}%)`:"";
    recEl.innerText=`Recurrence Prediction: ${rec.label}${conf}`;
  }else{
    recEl.innerText="";
  }
}
}catch(err){
    console.error(err);
    streaming=false;
    if(intervalId) clearInterval(intervalId);
    alert("Connection lost or server error — check console.");
  }
}
    // === Restored prediction logic ===
    if(filesUploaded){
      const pred=result.prediction||{};
      let disp=(pred&&typeof pred==='object')?(pred.smoothed||pred.raw||pred):null;
      if(!disp||!disp.label){
        document.getElementById("predictionResult").innerText="N/A";
        document.getElementById("predictionDescription").innerText="";
        document.getElementById("diseaseName").innerText="";
      }else{
        document.getElementById("predictionResult").innerText=disp.label||"N/A";
        document.getElementById("predictionDescription").innerText=disp.description||"";
        document.getElementById("diseaseName").innerText=disp.disease_name||"";
      }
      try{
        const rec=result.recurrence_prediction;
        if(rec&&rec.label){
          const descEl=document.getElementById("predictionDescription");
          const prev=descEl.innerText||"";
          const recTxt=`Recurrence: ${rec.label} (conf=${(rec.confidence||0).toFixed(2)})`;
          descEl.innerText=prev?prev+" | "+recTxt:recTxt;
        }
      }catch(e){}
    }

</script>
</body>
</html>
