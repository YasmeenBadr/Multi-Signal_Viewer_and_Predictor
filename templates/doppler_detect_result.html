<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Doppler Detection Result</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Inter', sans-serif;
      background: linear-gradient(135deg, #0a0e1a 0%, #1a1f35 100%);
      color: #fff;
      padding: 30px 20px;
      min-height: 100vh;
    }
    
    .container-fluid {
      max-width: 1600px;
      margin: 0 auto;
    }
    
    h1 {
      text-align: center;
      color: #00eaff;
      font-size: 2.5rem;
      font-weight: 700;
      margin-bottom: 40px;
      text-shadow: 0 0 20px rgba(0, 234, 255, 0.5);
    }
    
    /* Detection Results Cards */
    .results-row {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 20px;
      margin-bottom: 40px;
    }
    
    .result-card {
      background: rgba(26, 31, 53, 0.8);
      border: 2px solid #00eaff;
      border-radius: 15px;
      padding: 25px;
      text-align: center;
      box-shadow: 0 8px 32px rgba(0, 234, 255, 0.2);
    }
    
    .result-card h4 {
      color: #aaa;
      font-size: 1rem;
      font-weight: 600;
      margin-bottom: 10px;
    }
    
    .result-card .value {
      color: #00eaff;
      font-size: 2.5rem;
      font-weight: 700;
    }
    
    /* Sampling Control Box */
    .sampling-control {
      background: rgba(26, 31, 53, 0.9);
      border: 2px solid #00eaff;
      border-radius: 15px;
      padding: 30px;
      margin-bottom: 40px;
      box-shadow: 0 8px 32px rgba(0, 234, 255, 0.2);
    }
    
    .sampling-control h3 {
      color: #00eaff;
      font-size: 1.5rem;
      margin-bottom: 20px;
      text-align: center;
    }
    
    .slider-container {
      margin: 25px 0;
    }
    
    .slider-label {
      color: #00eaff;
      font-size: 1.2rem;
      font-weight: 600;
      text-align: center;
      display: block;
      margin-bottom: 15px;
    }
    
    .form-range {
      width: 100%;
      height: 8px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 5px;
      outline: none;
    }
    
    .form-range::-webkit-slider-thumb {
      width: 20px;
      height: 20px;
      background: #00eaff;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 0 10px rgba(0, 234, 255, 0.8);
    }
    
    .form-range::-moz-range-thumb {
      width: 20px;
      height: 20px;
      background: #00eaff;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 0 10px rgba(0, 234, 255, 0.8);
    }
    
    .range-labels {
      display: flex;
      justify-content: space-between;
      color: #aaa;
      font-size: 0.9rem;
      margin-top: 5px;
    }
    
    /* Status Indicator */
    .status-indicator {
      text-align: center;
      padding: 15px 25px;
      border-radius: 10px;
      font-weight: 700;
      font-size: 1.1rem;
      margin: 20px 0;
    }
    
    .status-good {
      background: rgba(0, 255, 0, 0.2);
      border: 2px solid #00ff00;
      color: #00ff00;
    }
    
    .status-warning {
      background: rgba(255, 200, 0, 0.2);
      border: 2px solid #ffc800;
      color: #ffc800;
    }
    
    .status-danger {
      background: rgba(255, 0, 0, 0.2);
      border: 2px solid #ff3333;
      color: #ff3333;
    }
    
    .info-text {
      text-align: center;
      color: #aaa;
      font-size: 0.95rem;
      margin: 10px 0;
    }
    
    .generate-btn {
      display: block;
      width: 100%;
      max-width: 400px;
      margin: 20px auto;
      background: linear-gradient(135deg, #00eaff 0%, #00c5cc 100%);
      color: #000;
      border: none;
      padding: 15px 30px;
      font-weight: 700;
      font-size: 1.1rem;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 4px 15px rgba(0, 234, 255, 0.4);
    }
    
    .generate-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0, 234, 255, 0.6);
    }
    
    .generate-btn:disabled {
      background: #555;
      cursor: not-allowed;
      transform: none;
    }
    
    /* Signal Comparison Grid */
    .signals-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 30px;
      margin: 40px 0;
    }
    
    @media (max-width: 1200px) {
      .signals-grid {
        grid-template-columns: 1fr;
      }
    }
    
    .signal-box {
      background: rgba(26, 31, 53, 0.9);
      border: 2px solid #00eaff;
      border-radius: 15px;
      padding: 25px;
      box-shadow: 0 8px 32px rgba(0, 234, 255, 0.2);
    }
    
    .signal-box h4 {
      color: #00eaff;
      font-size: 1.3rem;
      font-weight: 700;
      margin-bottom: 20px;
      text-align: center;
    }
    
    .signal-canvas {
      width: 100%;
      height: 300px;
      background: #0a0e1a;
      border-radius: 10px;
      border: 1px solid rgba(0, 234, 255, 0.3);
      margin: 15px 0;
      display: block;
    }
    
    .audio-player {
      width: 100%;
      margin: 15px 0;
      border-radius: 10px;
    }
    
    .signal-info {
      text-align: center;
      color: #aaa;
      font-size: 0.9rem;
      margin-top: 10px;
    }
    
    .back-btn {
      display: block;
      width: 200px;
      margin: 40px auto;
      background: rgba(255, 255, 255, 0.1);
      color: #fff;
      border: 2px solid #00eaff;
      padding: 12px 24px;
      font-weight: 600;
      border-radius: 8px;
      text-decoration: none;
      text-align: center;
      transition: all 0.3s;
    }
    
    .back-btn:hover {
      background: rgba(0, 234, 255, 0.2);
      color: #00eaff;
    }
  </style>
</head>

<body 
  data-f-original='{{ f_original | tojson }}'
  data-estimated-speed='{{ estimated_speed | tojson }}'
  data-y-plot='{{ y_plot_json | tojson }}'
  data-x-plot='{{ x_plot_json | tojson }}'
  data-audio-file-id='{{ audio_file_id | tojson }}'
>

  <div class="container-fluid">
    <h1>üöó Doppler Effect Detection Result</h1>

    <!-- Detection Results -->
    <div class="results-row">
      <div class="result-card">
        <h4>üéØ Predicted Speed</h4>
        <div class="value">{{ estimated_speed }} km/hr</div>
      </div>
      <div class="result-card">
        <h4>üìä Estimated Frequency</h4>
        <div class="value">{{ f_original }} Hz</div>
      </div>
    </div>

    <!-- Sampling Control -->
    <div class="sampling-control">
      <h3>üéöÔ∏è Sampling Rate & Aliasing Demonstration</h3>
      
      <div class="slider-container">
        <label id="samplingRateLabel" class="slider-label">Sampling Frequency: 44100 Hz</label>
        <input type="range" min="1000" max="48000" value="44100" step="1000" id="samplingSlider" class="form-range">
        <div class="range-labels">
          <span>1000 Hz</span>
          <span>24000 Hz</span>
          <span>48000 Hz</span>
        </div>
      </div>

      <div id="aliasingStatus" class="status-indicator status-good">Waiting for analysis...</div>
      
      <p class="info-text">
        Nyquist limit: <strong id="nyquistDisplay">-</strong> | 
        Aliasing threshold: <strong id="nyquistThreshold">-</strong>
      </p>

      <button id="generateBtn" class="generate-btn">üîÑ Generate Car Sound</button>
    </div>

    <!-- Signal Comparison -->
    <div class="signals-grid">
      <!-- Original Signal -->
      <div class="signal-box">
        <h4>üìÅ Original Uploaded Signal</h4>
        <canvas id="originalCanvas" class="signal-canvas"></canvas>
        <audio id="originalAudio" controls class="audio-player">
          <source src="{{ url_for('doppler.serve_audio', file_id=audio_file_id) }}" type="audio/wav">
        </audio>
        <p class="signal-info">Original file - Reference signal (unmodified)</p>
      </div>

      <!-- Generated Signal -->
      <div class="signal-box">
        <h4>üîä Generated Car Sound (After Sampling)</h4>
        <canvas id="sampledCanvas" class="signal-canvas"></canvas>
        <audio id="generatedAudio" controls class="audio-player"></audio>
        <p class="signal-info" id="generatedInfo">Click "Generate" to create resampled audio</p>
      </div>
    </div>

    <a href="{{ url_for('doppler.index') }}" class="back-btn">‚¨ÖÔ∏è Back to Upload</a>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', function() {
      const body = document.body;

      // Load data from HTML attributes
      let originalFreq = JSON.parse(body.dataset.fOriginal);
      let estimatedSpeed = JSON.parse(body.dataset.estimatedSpeed);
      let originalYData = JSON.parse(body.dataset.yPlot);
      let originalXData = JSON.parse(body.dataset.xPlot);
      let audioFileId = JSON.parse(body.dataset.audioFileId);

      console.log("=== DATA LOADED ===");
      console.log("Frequency:", originalFreq, "Hz");
      console.log("Speed:", estimatedSpeed, "km/hr");
      console.log("X data points:", originalXData.length);
      console.log("Y data points:", originalYData.length);
      console.log("X range:", Math.min(...originalXData), "to", Math.max(...originalXData));
      console.log("Y range:", Math.min(...originalYData), "to", Math.max(...originalYData));
      console.log("First 5 X values:", originalXData.slice(0, 5));
      console.log("First 5 Y values:", originalYData.slice(0, 5));

      const nyquistFrequency = Math.round(originalFreq * 2 * 3);
      const moderateAliasingThreshold = Math.round(nyquistFrequency * 0.8);

      document.getElementById('nyquistDisplay').textContent = nyquistFrequency + ' Hz';
      document.getElementById('nyquistThreshold').textContent = moderateAliasingThreshold + ' Hz';

      // Draw original signal immediately
      drawOriginalSignal();

      // Slider event
      const slider = document.getElementById('samplingSlider');
      slider.addEventListener('input', function(e) {
        const selectedFs = parseInt(e.target.value);
        document.getElementById('samplingRateLabel').textContent = `Sampling Frequency: ${selectedFs} Hz`;
        updateAliasingStatus(selectedFs);
      });
      updateAliasingStatus(parseInt(slider.value));

      // Generate button
      const generateBtn = document.getElementById('generateBtn');
      generateBtn.addEventListener('click', function() {
        const selectedFs = parseInt(slider.value);
        console.log("üéõÔ∏è Generate clicked, fs:", selectedFs);
        generateNewCarSound(selectedFs);
      });

      // Auto-generate on load
      setTimeout(() => {
        generateNewCarSound(parseInt(slider.value));
      }, 1000);

      function updateAliasingStatus(fs) {
        const statusElement = document.getElementById('aliasingStatus');
        
        if (fs >= nyquistFrequency) {
          statusElement.innerHTML = '‚úÖ <strong>No aliasing expected</strong> - Sampling rate above Nyquist';
          statusElement.className = 'status-indicator status-good';
        } else if (fs >= moderateAliasingThreshold) {
          statusElement.innerHTML = '‚ö†Ô∏è <strong>Moderate aliasing possible</strong> - Near Nyquist limit';
          statusElement.className = 'status-indicator status-warning';
        } else {
          statusElement.innerHTML = '‚ùå <strong>Severe aliasing expected</strong> - Far below Nyquist';
          statusElement.className = 'status-indicator status-danger';
        }
      }

      function drawOriginalSignal() {
        console.log("=== DRAWING ORIGINAL SIGNAL ===");
        const canvas = document.getElementById('originalCanvas');
        if (!canvas) {
          console.error("‚ùå Canvas not found!");
          return;
        }
        
        const ctx = canvas.getContext('2d');
        const width = canvas.width = canvas.offsetWidth;
        const height = canvas.height = canvas.offsetHeight;
        
        console.log("Canvas size:", width, "x", height);
        
        // Clear and fill background
        ctx.clearRect(0, 0, width, height);
        ctx.fillStyle = '#0a0e1a';
        ctx.fillRect(0, 0, width, height);
        
        // Draw grid
        ctx.strokeStyle = 'rgba(0, 234, 255, 0.1)';
        ctx.lineWidth = 1;
        for (let x = 0; x < width; x += 50) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, height);
          ctx.stroke();
        }
        for (let y = 0; y < height; y += 50) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(width, y);
          ctx.stroke();
        }
        
        // Draw center line
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(0, height / 2);
        ctx.lineTo(width, height / 2);
        ctx.stroke();
        
        // Check data validity
        if (!originalXData || !originalYData || originalXData.length === 0 || originalYData.length === 0) {
          console.error("‚ùå No data to plot!");
          ctx.fillStyle = '#ff3333';
          ctx.font = '16px Inter';
          ctx.textAlign = 'center';
          ctx.fillText('No data available', width / 2, height / 2);
          return;
        }
        
        if (originalXData.length !== originalYData.length) {
          console.error("‚ùå X and Y data length mismatch!", originalXData.length, "vs", originalYData.length);
          return;
        }
        
        console.log("Drawing signal with", originalYData.length, "points");
        
        // Draw signal - USE Y DATA DIRECTLY WITHOUT X (it's just indices)
        ctx.beginPath();
        const xScale = width / originalYData.length;
        const yScale = height * 0.45;  // Use 45% of height for amplitude
        
        // Find min/max for better scaling
        const yMin = Math.min(...originalYData);
        const yMax = Math.max(...originalYData);
        const yRange = yMax - yMin;
        console.log("Y range:", yMin, "to", yMax, "| Range:", yRange);
        
        for (let i = 0; i < originalYData.length; i++) {
          const x = i * xScale;
          // Center the signal and scale it
          const y = (height / 2) - (originalYData[i] * yScale);
          
          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        
        ctx.strokeStyle = "#00eaff";
        ctx.lineWidth = 2;
        ctx.stroke();
        
        console.log("‚úÖ Original signal drawn successfully!");
      }

      function drawSampledSignal(xData, yData) {
        console.log("=== DRAWING SAMPLED SIGNAL ===");
        const canvas = document.getElementById('sampledCanvas');
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        const width = canvas.width = canvas.offsetWidth;
        const height = canvas.height = canvas.offsetHeight;
        
        ctx.clearRect(0, 0, width, height);
        ctx.fillStyle = '#0a0e1a';
        ctx.fillRect(0, 0, width, height);
        
        // Draw grid
        ctx.strokeStyle = 'rgba(0, 234, 255, 0.1)';
        ctx.lineWidth = 1;
        for (let x = 0; x < width; x += 50) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, height);
          ctx.stroke();
        }
        for (let y = 0; y < height; y += 50) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(width, y);
          ctx.stroke();
        }
        
        // Draw center line
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(0, height / 2);
        ctx.lineTo(width, height / 2);
        ctx.stroke();
        
        if (xData && yData && yData.length > 0) {
          console.log("Drawing", yData.length, "points");
          
          ctx.beginPath();
          const xScale = width / yData.length;
          const yScale = height * 0.45;
          
          for (let i = 0; i < yData.length; i++) {
            const x = i * xScale;
            const y = (height / 2) - (yData[i] * yScale);
            
            if (i === 0) {
              ctx.moveTo(x, y);
            } else {
              ctx.lineTo(x, y);
            }
          }
          
          ctx.strokeStyle = "#00eaff";
          ctx.lineWidth = 2;
          ctx.stroke();
          
          document.getElementById('generatedInfo').textContent = `Resampled at ${document.getElementById('samplingSlider').value} Hz - ${yData.length} samples`;
          console.log("‚úÖ Sampled signal drawn!");
        } else {
          ctx.fillStyle = '#00eaff';
          ctx.font = '16px Inter';
          ctx.textAlign = 'center';
          ctx.fillText('Click "Generate" to create signal', width / 2, height / 2);
        }
      }

      function generateNewCarSound(targetFs) {
        const canvas = document.getElementById('sampledCanvas');
        const ctx = canvas.getContext('2d');
        const width = canvas.offsetWidth;
        const height = canvas.offsetHeight;
        const generateBtn = document.getElementById('generateBtn');
        
        // Show loading
        ctx.clearRect(0, 0, width, height);
        ctx.fillStyle = '#0a0e1a';
        ctx.fillRect(0, 0, width, height);
        ctx.fillStyle = '#00eaff';
        ctx.font = '18px Inter';
        ctx.textAlign = 'center';
        ctx.fillText('üîÑ Generating...', width / 2, height / 2);

        generateBtn.textContent = 'üîÑ Generating...';
        generateBtn.disabled = true;

        fetch('{{ url_for("doppler.generate_downsampled_audio") }}', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            target_fs: targetFs,
            estimated_speed: estimatedSpeed,
            estimated_freq: originalFreq
          })
        })
        .then(res => {
          if (!res.ok) throw new Error('Server error');
          return res.json();
        })
        .then(data => {
          console.log("‚úÖ Response:", data);
          
          if (data.success) {
            // Update audio
            const audioPlayer = document.getElementById('generatedAudio');
            const newSrc = '{{ url_for("doppler.serve_audio", file_id="") }}' + data.generated_file_id + '?t=' + Date.now();
            audioPlayer.src = newSrc;
            audioPlayer.load();
            
            // Draw signal
            if (data.x_plot && data.y_plot) {
              drawSampledSignal(data.x_plot, data.y_plot);
            }
            
            console.log("üéâ Generation complete!");
          } else {
            throw new Error(data.error || 'Unknown error');
          }
        })
        .catch(err => {
          console.error("‚ùå Error:", err);
          ctx.clearRect(0, 0, width, height);
          ctx.fillStyle = '#0a0e1a';
          ctx.fillRect(0, 0, width, height);
          ctx.fillStyle = '#ff3333';
          ctx.font = '16px Inter';
          ctx.textAlign = 'center';
          ctx.fillText('Error: ' + err.message, width / 2, height / 2);
        })
        .finally(() => {
          generateBtn.textContent = 'üîÑ Generate Car Sound';
          generateBtn.disabled = false;
        });
      }
    });
  </script>
</body>
</html>